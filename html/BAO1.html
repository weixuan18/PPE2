<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="./css/sous-style1.css" />
        <link href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet" />
        <link href = "./img/avatar_ppe2.png" rel = "SHORTCUT ICON">
        <title>bao1</title>
    </head>
    <body>
        <header class="header">
            <a href="#" class="logo">Projet Encadré: <h1 class="title">Boite À Outils 1</h1></a>
            <nav class="navbar">
                <a href="./index.html" class="item" style="--i: 1">Accueil</a>
                <a href="./BAO1.html" class="active item" style="--i:  2">BAO1</a>
                <a href="./BAO2.html" class="item" style="--i:  3">BAO2</a>
                <a href="./BAO3.html" class="item" style="--i:  4">BAO3</a>
                <a href="./BAO4.html" class="item" style="--i:  5">BAO4</a>
            </nav>
        </header>
        <section id="wrapper">
            <header>
                <div class="inner">
                    <h2>Boîte à Outils 1</h2>
                    <p>Lecture de fichiers RSS, Extraction (récursive) de texte et métadonnées</p>
                </div>
            </header>
            <!-- Content -->
            <div class="wrapper">
                <div class="inner">
                    <h3 class="major">Idée principale</h3>
                    <p align = "justify">RSS (« Really Simple Syndication ») est une des applications de XML, qui est
                        généré automatiquement et régulièrement pendant la mise à jour d’un site
                        web. Il comporte les titres et les résumés des dernières infos, qui nous
                        permet de suivre les nouvelles d’un site. Pour commencer, on utilise l’ensemble des
                        fils RSS de l’année 2022, recueilli par M. Fleury, en tant que notre corpus de
                        travail.</p>
                    <p align = "justify">La première méthode serait d'utiliser le module "etree" "re" "feedparser" en
                        Python pour extraire les titres et les descriptions des fichiers xml. Au bout de l'expérimentation,
                        nus constatons que "etree" est plus simple au module "re", car il s'adapte à la
                        structure de XML avec les fonctions "root()" et "tree()". Il est ainsi possible de
                        détecter les titres et les descriptions du item en respectant le chemin et
                        la forme <code>root.findall(".//item")</code>. En plus, en utilisant ce module-ci, les
                        crochet à la fin et les caractères au début (CDATA) ne seront pas affichés
                        dans le résultat, ce qui se produit souvent lors de l'application de "re" .</p>
                    <p align = "justify">Après avoir eu un aperçu sur les manipulations de ces trois modules en classe, nous avons
                        donc décidé d'utiliser le module "feedparser" comme notre méthode d'extraction principale.
                        Ce dernier s'adapte précisément à la structure de XML tout en évitant
                        les problèmes liés à des balises. Mais aussi, le module est beaucoup moins complexe quant à 
                        son application par rapport aux deux autres.</p>
                    <p align = "justify">Néanmoins, afin que le script puisse traiter tous les fichiers tout d'un coup, on devrait aussi 
                        penser à l’idée de récursivité, qui nous permet de parcourir le corpus arborescent.
                        Le parcours récursif, plus concrètement dans notre projet, pourrait être expliqué par un bloc de pseudocode Fonction "parcours_dossier(corpus_dir)":</p>
                    <pre><code>On entre dans le dossier corpus_dir et on explore son contenu(élément f):
- Si f est un fichier xml:   extraire(f)
- Si f est un dossier:   parcours_dossier(f)</code></pre>
                    <p align = "justify">Dans ce cas, nous avons essayé deux modules bien utiles "pathlib" et "os".</p>
                    <p align = "justify">Enfin en employant "argparser", on pourrait simplement parvenir à notre obejctif en
                        déterminant les arguments lors du lancement du script en question. Il nous renvoie les résultats d'extraction des sous-parties que nous souhaitons.
                    En outre, noous avons proposé trois manières de sérialiser notre résultat dans les arguments à l'aide du module "json", "pickle" et bien sûr "etree".</p>
                    <h3 class="major">Script</h3>
                    <p align = "justify">Finalement, nous avons décidé de choisir 3 rubriques à traiter : "une", "international",
                        "politique". Nous mettons le script établi et les résultats obtenus ci-dessous.</p>
                    <ul class="actions">
                        <li>
                            <a href="./fichiers/scripts/extraire_many.py" class="button primary"
                                >Script</a>
                        </li>
                        <li>
                            <a href="https://gitlab.com/XINHAO-ZHANG/ppe2_chz/-/tree/main/corpus/une_inter_poli/une" class="button">Résultat UNE</a>
                        </li>
                        <li>
                            <a href="https://gitlab.com/XINHAO-ZHANG/ppe2_chz/-/tree/main/corpus/une_inter_poli/international" class="button">Résultat INTERNATIONAL</a>
                        </li>
                        <li>
                            <a href="https://gitlab.com/XINHAO-ZHANG/ppe2_chz/-/tree/main/corpus/une_inter_poli/politique" class="button">Résultat POLITIQUE</a>
                        </li>
                    </ul>
                    <pre><code>#!/usr/bin/env python3
from typing import Optional, List, Dict
import xml.etree.ElementTree as ET
import argparse
import re
from pathlib import Path
from datetime import date  # pour renvoyer dans le bon ordre chronologique
from tqdm import tqdm

from extraire_un import extraire_td, extraire_a
from datastructures import Corpus, Article, Token
from export_xml import write_xml
from export_json import write_json
from export_pickle import write_pickle

MONTHS = ["Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"]

DAYS = [f"{x:02}" for x in range(1, 32)]

# Définir le dictionnaire de correspondance entre les catégories et les noms de fichiers XML
categories_dict = {
    "une": "0,2-3208,1-0,0",
    "international": "0,2-3210,1-0,0",
    "europe": "0,2-3214,1-0,0",
    "societe": "0,2-3224,1-0,0",
    "idees": "0,2-3232,1-0,0",
    "economie": "0,2-3234,1-0,0",
    "actualite-medias": "0,2-3236,1-0,0",
    "sport": "0,2-3242,1-0,0",
    "planete": "0,2-3244,1-0,0",
    "culture": "0,2-3246,1-0,0",
    "livres": "0,2-3260,1-0,0",
    "cinema": "0,2-3476,1-0,0",
    "voyage": "0,2-3546,1-0,0",
    "technologies": "0,2-651865,1-0,0",
    "politique": "0,57-0,64-823353,0",
    "sciences": "env_sciences"
}
new_dict = {valeur: cle for cle, valeur in categories_dict.items()}


def categorie_of_filename(filename: str) -> Optional[str]:
    for nom, code in categories_dict.items():
        if code in filename:
            return nom
    return None


def convert_month(m: str) -> int:
    return MONTHS.index(m) + 1


def parcours_dossier(corpus_dir: Path, categories: Optional[List[str]] = None,
                        start_date: Optional[date] = None, end_date: Optional[date] = None):
    if categories is not None and len(categories) > 0:
        categories = [categories_dict[c.lower()] for c in categories]
    else:
        categories = categories_dict.values()

    for month_dir in corpus_dir.iterdir():
        if not month_dir.is_dir():
            continue
        m = convert_month(month_dir.name)
        for day_dir in month_dir.iterdir():
            if not day_dir.is_dir():
                continue
            d = date.fromisoformat(f"2022-{m:02}-{day_dir.name}")
            if (start_date is not None and d < start_date) or (end_date is not None and d > end_date):
                continue
            for hour_dir in day_dir.iterdir():
                if not hour_dir.is_dir():
                    continue
                if re.match(r"\d{2}-\d{2}-\d{2}", hour_dir.name):
                    for xml_file in hour_dir.iterdir():
                        if xml_file.name.endswith(".xml") and any([xml_file.name.startswith(c) for c in categories]):
                            # yield(xml_file.name, extraire_td(xml_file.as_posix()))
                            c = categorie_of_filename(xml_file.name)
                            yield xml_file, d.isoformat(), c


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-s", help="start date (iso format)", default="2022-01-01")
    parser.add_argument("-e", help="end date (iso format)",
                        default="2023-01-01")
    parser.add_argument(
        "-o", help="output file (stdout si non spécifié)", required=True)
    parser.add_argument(
        "-f", help="format de sortie (xml par défault)", choices = ['xml','json','pickle'], default="xml",required = True)
    parser.add_argument(
        "-p", help="parser à utiliser (spacy par défault)",choices = ['spacy','stanza','trankit'], required = True, default="spacy")
    parser.add_argument("corpus_dir", help="la racine du dossier")
    parser.add_argument("categories", nargs="*", help="catégories à retenir")
    args = parser.parse_args()
    corpus = Corpus(categories=args.categories, begin=args.s,
                    end=args.e, chemin=Path(args.corpus_dir), articles=[])
    for xml_file, d, c in tqdm(parcours_dossier(Path(args.corpus_dir), args.categories, date.fromisoformat(args.s), date.fromisoformat(args.e))):
        for article in extraire_a(xml_file, d, c):
            corpus.articles.append(article)
    if args.p == "spacy" or args.p == None:
        import analyse_sp as analyse
    elif args.p == "stanza":
        import analyse_st as analyse
    elif args.p == "trankit":
        import analyse_tk as analyse
    for a in tqdm(corpus.articles):
        parser = analyse.create_parser()
        analyse.analyse_article(parser, a)
    if args.o is None:
        for title, description in extraire_td(args.corpus_dir):
            print(title)
            print(description)
    if args.o is not None:
        if args.f == "xml":
            write_xml(corpus, args.o)
        elif args.f == "json":
            write_json(corpus, args.o)
        elif args.f == "pickle":
            write_pickle(corpus, args.o)
        else:
            print("format non supporté")


if __name__ == "__main__":
    main()
                        
# exemple d'utilisation: python3 extraire_deux.py -s 2022-01-01 -e 2022-01-31 -o corpus.xml /home/.../corpus une international                                  
                    </code></pre>
                    <section class="features">
                        <article>
                            <h3 class="major">boîte à outils 2</h3>
                            <p>Enrichissement des données</p>
                            <a href="./BAO2.html" class="special">Savoir plus</a>
                        </article>
                        <article>
                            <h3 class="major">boîte à outils 3</h3>
                            <p>Récupération automatique des patrons</p>
                            <a href="./BAO3.html" class="special">Savoir plus</a>
                        </article>
                    </section>
                </div>
            </div>
        </section>
        <footer id="footer">
            <ul class="copyright">
                <li>&copy; ppe2_chz</li>
                <li>Xinhao, Weixuan, Yidi</li>
            </ul>
        </footer>
        <!--scripts-->
        <script src="javascript/jquery.min.js"></script>
        <script src="javascript/jquery.scrollex.min.js"></script>
        <script src="javascript/browser.min.js"></script>
        <script src="javascript/breakpoints.min.js"></script>
        <script src="javascript/util.js"></script>
    </body>
</html>

